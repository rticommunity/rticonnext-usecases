/* Note: this file has extensinon .cxx but it actually contains plain C only */

/* Interface */
#include "connext_micro_log_trace_handlers.h"


/* Implementation */
#include "stdlib.h"

//#define OSAPI_ENABLE_LOG   (1)
//#define OSAPI_ENABLE_TRACE (1)

#include "osapi/osapi_log.h"
#include "osapi/osapi_string.h"
#include "osapi/osapi_process.h"
#include "connext_micro_ec_log_info.i" /* Code generated by awk script */

static FILE *G_traceFilePtr = NULL;
static struct OSAPI_Mutex *G_logLock = NULL;

static const char *
LogTrace_get_log_kind_name(RTI_UINT32 error_code)
{
	const char *result = NULL;
#define CASE_MACRO(kindName) \
	case OSAPI_LOGKIND_ ## kindName: \
	   result = #kindName; \
	   break


	switch (OSAPI_LOG_HEADER_GET_TYPE(error_code))
	{
	CASE_MACRO(INFO);
	CASE_MACRO(WARNING);
	CASE_MACRO(ERROR);
	CASE_MACRO(PRECONDITION);
	default:
		result = "<UNKNOWN>";
	}

#undef CASE_MACRO

	return result;
}


static bool
LogTrace_lookup_error_info(RTI_UINT32 error_code,
    const char **name, const char **module_name,
    const char **definition, const char **definition_file,
    const char **brief)
{
    RTI_BOOL result = RTI_FALSE;
    int index;
    unsigned int lookup_value;
    struct ec_log_info found_info;

    lookup_value = error_code & 0x07ff7fff;
    for (index = 0; (index < EC_LOG_INFO_COUNT) && !result; index++) {
      result = (lookup_value == S_ec_log_infos[index].value);
      if (result) {
        found_info = S_ec_log_infos[index];
        *name = found_info.name;
        *module_name = found_info.module_name;
        *definition = found_info.definition;
        *definition_file = found_info.definition_file;
        *brief = found_info.brief;
      }
    }

    return result;
}


static void
helloworld_display_handler(void *param, OSAPI_LogEntry_T *log_entry)
{
	RTI_BOOL retval;
	static int S_log_count = 0;
    RTI_UINT32 status = 0;

    /* Basic log values */
    RTI_UINT32 error_code;
    const char *log_kind = NULL;
    RTI_INT32 sec;
    RTI_UINT32 nsec;
    RTI_UINT32 error_id;
    RTI_UINT32 error_module_id;
    RTI_BOOL F_bit;
    RTI_BOOL X_bit;
    RTI_BOOL E_bit;
    RTI_BOOL T_bit;

    /* Extended information about log message */
    const char *error_name = NULL;
    const char *error_module_name = NULL;
    const char *error_definition = NULL;
    const char *error_definition_file = NULL;
    const char *error_description = NULL;

    /* Source code location information (if X-bit is set) */
    char *X_data_ptr;
    const char *module = "<not found>";
    const char *file = "<not found>";
    const char *func = "<not found>";
    RTI_INT32 lineno = -1;

    /* Additional log values */
    char *value_data_ptr;
    OSAPI_LogType_T value_type;
    RTI_BOOL is_final = RTI_FALSE;
    const char *name;
    const void *value;
    const char *err_msg;

    UNUSED_ARG(param);

    retval = OSAPI_Mutex_take(G_logLock);
    if (!retval) {
    	printf("Error in helloworld_display_handler: unable to take log lock\n");
    	goto done;
    }

    S_log_count++;
    error_code = log_entry->error_code;

    log_kind = LogTrace_get_log_kind_name(error_code);
    OSAPI_NtpTime_to_nanosec(&sec, &nsec, &log_entry->timestamp);
    error_module_id = OSAPI_LOG_HEADER_GET_MODULE(error_code);
    error_id = OSAPI_LOG_HEADER_GET_EC(error_code);
    F_bit = OSAPI_LOG_HEADER_GET_F(error_code);
    X_bit = OSAPI_LOG_HEADER_GET_X(error_code);
    E_bit = OSAPI_LOG_HEADER_GET_E(error_code);
    T_bit = OSAPI_LOG_HEADER_GET_T(error_code);

    retval = LogTrace_lookup_error_info(error_code,
    		&error_name, &error_module_name,
    		&error_definition, &error_definition_file,
    		&error_description);

	fprintf(G_traceFilePtr, "\n");
    fprintf(G_traceFilePtr, "Log message %d received\n", S_log_count);
    fprintf(G_traceFilePtr, "  Time       :  [%d.%d]\n", sec, nsec);
    fprintf(G_traceFilePtr, "  Kind       :  %s\n", log_kind);
    fprintf(G_traceFilePtr, "  Error code :  0x%08x (%u)\n", error_code, error_id);
    if (retval) {
        fprintf(G_traceFilePtr, "    Name     :  %s\n", error_name);
        fprintf(G_traceFilePtr, "    Module   :  %s (%d)\n", error_module_name, error_module_id);
        fprintf(G_traceFilePtr, "    Defined  :  %s (%s)\n", error_definition, error_definition_file);
        fprintf(G_traceFilePtr, "    Brief    :  %s\n", error_description);
    }
    fprintf(G_traceFilePtr, "  F-bit      :  %s\n", F_bit ? "set" : "not set");
    fprintf(G_traceFilePtr, "  X-bit      :  %s\n", X_bit ? "set" : "not set");
    fprintf(G_traceFilePtr, "  E-bit      :  %s\n", E_bit ? "set" : "not set");
    fprintf(G_traceFilePtr, "  T-bit      :  %s\n", T_bit ? "set" : "not set");

    if (X_bit)
    {
        X_data_ptr = (char*)&log_entry[1];
        status = *(RTI_INT32*)X_data_ptr;
        X_data_ptr += sizeof(RTI_INT32);
        if (status & OSAPI_LOG_STATUS_LN)
        {
            lineno = *(RTI_INT32*)X_data_ptr;
            X_data_ptr += (RTI_INT32)sizeof(RTI_INT32);
        }
        if (status & OSAPI_LOG_STATUS_MN)
        {
            module = X_data_ptr;
            X_data_ptr += OSAPI_String_length(X_data_ptr) + 1;
        }
        if (status & OSAPI_LOG_STATUS_SF)
        {
            file = X_data_ptr;
            X_data_ptr += OSAPI_String_length(X_data_ptr) + 1;
        }
        if (status & OSAPI_LOG_STATUS_FN)
        {
            func = X_data_ptr;
            X_data_ptr += OSAPI_String_length(X_data_ptr) + 1;
        }
        if (status & OSAPI_LOG_STATUS_F)
        {
            X_data_ptr += OSAPI_String_length(X_data_ptr) + 1;
        }
        fprintf(G_traceFilePtr, "  Source     :\n");
        fprintf(G_traceFilePtr, "    Module   : %s\n", module);
        fprintf(G_traceFilePtr, "    File     : %s\n", file);
        fprintf(G_traceFilePtr, "    Line     : %d\n", lineno);
        fprintf(G_traceFilePtr, "    Function : %s\n", func);
    } else {
        fprintf(G_traceFilePtr, "  Source     : <not available>\n");
    }

    /* Get additional values */
    value_data_ptr = NULL;
    is_final = RTI_FALSE;

    while (OSAPI_Log_entry_get_data(log_entry, &value_data_ptr, &value_type,
                                    &name, &value, &is_final))
    {
        fprintf(G_traceFilePtr, "  Additional value \"%s\" : ", name);
        switch (value_type)
        {
        case OSAPI_LOGTYPE_INTEGER:
            fprintf(G_traceFilePtr, "%d | %u | 0x%08X [int]\n",
            		*(int *)value, *(int *)value, *(int *)value);
            /* Special case: sysrc seems to be errno value, so try to print sys err */
            if (!strcmp(name, "sysrc")) {
            	/* strerror definition actually is const char * */
            	err_msg = (const char *)strerror(*(int *)value);
            	if (NULL != err_msg) {
            	    fprintf(G_traceFilePtr, "    System errmsg : \"%s\"\n", err_msg);
            }
         }
         break;
      case OSAPI_LOGTYPE_POINTER:
         fprintf(G_traceFilePtr, "%p [ptr]\n", value);
         break;
      case OSAPI_LOGTYPE_STRING:
         fprintf(G_traceFilePtr, "\"%s\" [str]\n", (char *)value);
         break;
      default:
     	   fprintf(G_traceFilePtr, "%p [unknown type]\n", value);
         break;
      }
      if (is_final) {
         break;
      }
   }
	fflush(G_traceFilePtr);

   retval = OSAPI_Mutex_give(G_logLock);
   IGNORE_RETVAL(retval);

done:
    return;
}

static void
helloworld_trace_handler(RTI_UINT32 trace_mask,void *param,RTI_INT32 context,
	                            const char *const module,const char *const file,
	                            const char *const function,RTI_INT32 line_no,
	                            OSAPI_TraceType_T type,const void *title,
	                            RTI_INT32 intv,const void *ptrv,const char *strv,
	                            RTI_BOOL is_final)
{
	RTI_BOOL retval;
	static int S_trace_count = 0;

	RTI_INT32 sec;
	RTI_UINT32 nsec;
	struct OSAPI_NtpTime timestamp;
	struct OSAPI_NtpTime zero_time = OSAPI_NTP_TIME_ZERO;
	RTI_INT32 pid;
	RTI_INT32 *intptr;

    retval = OSAPI_Mutex_take(G_logLock);
    if (!retval) {
    	printf("Error in helloworld_trace_handler: unable to take log lock\n");
    	goto done;
    }

    S_trace_count++;

	if (type == OSAPI_TRACETYPE_HEADER)
	{
		if (!OSAPI_System_get_time(&timestamp)) {
			timestamp = zero_time;
		}
		OSAPI_NtpTime_to_nanosec(&sec, &nsec, &timestamp);
		pid = OSAPI_Process_getpid();

	  	fprintf(G_traceFilePtr, "\n");
	    fprintf(G_traceFilePtr, "Trace message received:\n");
	    fprintf(G_traceFilePtr, "  Title      : %s\n", title ? (const char *)title : "<NULL>");
	    fprintf(G_traceFilePtr, "    Count      : %d\n", S_trace_count);
	    fprintf(G_traceFilePtr, "    Type       : HEADER\n");
	    fprintf(G_traceFilePtr, "    Time       : [%d.%d]\n", sec, nsec);
	    fprintf(G_traceFilePtr, "    Pid        : %d\n", pid);
	    fprintf(G_traceFilePtr, "    Context    : %d\n", context);
	    fprintf(G_traceFilePtr, "    Module     : %s\n", module ? module : "<NULL>");
	    fprintf(G_traceFilePtr, "    File       : %s\n", file ? file : "<NULL>");
	    fprintf(G_traceFilePtr, "    Function   : %s\n", function ? function : "<NULL>");
	    fprintf(G_traceFilePtr, "    LineNo     : %d\n", line_no);
	}
	else
	{
	    fprintf(G_traceFilePtr, "  Title      : %s\n", title ? (const char *)title : "<NULL>");
	    fprintf(G_traceFilePtr, "    Count      : %d\n", S_trace_count);
	    fprintf(G_traceFilePtr, "    Context    : %d\n", context);
	    fprintf(G_traceFilePtr, "    LineNo     : %d\n", line_no);
		switch (type)
		{
		case OSAPI_TRACETYPE_GUID:
			intptr = (RTI_INT32 *)ptrv;
		    fprintf(G_traceFilePtr, "    Type       : GUID\n");
		    fprintf(G_traceFilePtr, "    Value      : {%08X-%08X-%08X-%08X}\n",
		    		intptr[0], intptr[1], intptr[2], intptr[3]);
			break;
		case OSAPI_TRACETYPE_INT32:
		    fprintf(G_traceFilePtr, "    Type       : INT32\n");
		    fprintf(G_traceFilePtr, "    Value      : %d | %u | 0x%08X\n",
		    		intv, intv, intv);
			break;
		case OSAPI_TRACETYPE_STRING:
		    fprintf(G_traceFilePtr, "    Type       : STRING\n");
		    fprintf(G_traceFilePtr, "    Value      : \"%s\"\n", strv);
			break;
		case OSAPI_TRACETYPE_V4_AS_INT32:
			intptr = (RTI_INT32 *)ptrv;
		    fprintf(G_traceFilePtr, "    Type       : V4_AS_INT32\n");
		    fprintf(G_traceFilePtr, "    Value      : %d\n", intptr[0]);
			break;
		case OSAPI_TRACETYPE_V12_AS_INT32:
			intptr = (RTI_INT32 *)ptrv;
		    fprintf(G_traceFilePtr, "    Type       : V12_AS_INT32\n");
		    fprintf(G_traceFilePtr, "    Value      : %d %d %d\n",
		    		intptr[0], intptr[1], intptr[2]);
			break;
		default:
			break;
		}
	}
	fflush(G_traceFilePtr);

    retval = OSAPI_Mutex_give(G_logLock);
    IGNORE_RETVAL(retval);

done:
    return;


}


bool
LogTraceHandlers_Initialize(const char *fileNamePrefix)
{
	bool result = false;
	RTI_BOOL retval;
	const char *templ = "XXXXXX";
#define MAX_FILENAME_LEN (50)
	char tmpFileName[MAX_FILENAME_LEN];
	int remainder = MAX_FILENAME_LEN;

	/* Instantiate lock */
    G_logLock = OSAPI_Mutex_new();
    if (NULL == G_logLock) {
        printf("Failed to create mutex to protect log and trace handlers\n");
        goto done;
    }

    retval = OSAPI_Mutex_take(G_logLock);
    if (!retval) {
        printf("Failed to take mutex\n");
        goto done;
    }
    /* Open file */
    if (NULL == fileNamePrefix) {
        fileNamePrefix = "log";
    }
    strncpy(tmpFileName, fileNamePrefix, remainder);
    remainder -= strlen(fileNamePrefix);
    strncat(tmpFileName, templ, remainder);
	mkstemp(tmpFileName);

	if ('\0' != *tmpFileName) {
		G_traceFilePtr = fopen(tmpFileName, "w");
		if (NULL == G_traceFilePtr) {
			printf("Failed to open file \"%s\" for trace output, using stdout\n",
					tmpFileName);
		} else {
			printf("Opened file \"%s\" for trace output\n",
					tmpFileName);
		}
	}
	if (NULL == G_traceFilePtr) {
		G_traceFilePtr = stdout;
	}

    /* Uncomment to increase verbosity level: */
    OSAPI_Log_set_verbosity(OSAPI_LOG_VERBOSITY_DEBUG);
    retval = OSAPI_Log_set_display_handler(helloworld_display_handler, NULL);
    if (RTI_TRUE != retval) {
    	printf("Failed to install display handler\n");
    	goto done_locked;
    }

#if 0
    OSAPI_Trace_set_trace_mask(0xffffffff);
    retval = OSAPI_Log_set_trace_handler(helloworld_trace_handler, NULL);
    if (RTI_TRUE != retval) {
    	printf("Failed to install display handler\n");
    	goto done_locked;
    }
#endif

    result = true;

done_locked:
    retval = OSAPI_Mutex_give(G_logLock);
    IGNORE_RETVAL(retval);
 done:
	return result;
}


bool
LogTraceHandlers_Finalize(void)
{
	bool result = false;
	RTI_BOOL retval;

	/* Finalize logging */
	retval = OSAPI_Log_finalize();
	IGNORE_RETVAL(retval);

	/* Finalize system */
	retval = OSAPI_System_finalize();
	IGNORE_RETVAL(retval);

	/* Destroy mutex */
	if (NULL != G_logLock) {
		retval = OSAPI_Mutex_delete(G_logLock);
		IGNORE_RETVAL(retval);
		G_logLock = NULL;
	}

	/* Close file, if needed */
	if (NULL != G_traceFilePtr) {
		fclose(G_traceFilePtr);
	}

	/* Destroy lock, if needed */

	result = true;

	return result;
}
